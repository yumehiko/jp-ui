import{r as t}from"./iframe-CbECxjq5.js";import{u as ue}from"./useStableCallback-D6w4asaT.js";import{u as pe}from"./useTimeout-BMAPPt2Y.js";import{f as Te,u as ie,b as we}from"./mergeClassName-IXwn37SS.js";import{s as Ne}from"./styles-CrCElcc7.js";import{u as De}from"./useBaseUiId-DYV6Jlu1.js";import{j as Me}from"./jsx-runtime-u17CrQMm.js";import{c as Ke}from"./element-C8qsRkBu.js";import{r as Ze}from"./index-D8RucqKe.js";import{c as qe}from"./detectBrowser-CYw91I8L.js";import{u as Ue}from"./DirectionContext-DoIPesKM.js";import{c as V}from"./clamp-DyuOe9kr.js";const Fe=t.createContext(void 0);function de(){const e=t.useContext(Fe);if(e===void 0)throw new Error(Te(53));return e}let ge=(function(e){return e.scrollAreaCornerHeight="--scroll-area-corner-height",e.scrollAreaCornerWidth="--scroll-area-corner-width",e})({});const ve=500,Ie=16;function P(e,r,h){if(!e)return 0;const L=getComputedStyle(e),U=h==="x"?"Inline":"Block";return h==="x"&&r==="margin"?parseFloat(L[`${r}InlineStart`])*2:parseFloat(L[`${r}${U}Start`])+parseFloat(L[`${r}${U}End`])}let Ge=(function(e){return e.orientation="data-orientation",e.hovering="data-hovering",e.scrolling="data-scrolling",e.hasOverflowX="data-has-overflow-x",e.hasOverflowY="data-has-overflow-y",e.overflowXStart="data-overflow-x-start",e.overflowXEnd="data-overflow-x-end",e.overflowYStart="data-overflow-y-start",e.overflowYEnd="data-overflow-y-end",e})({}),ce=(function(e){return e.hasOverflowX="data-has-overflow-x",e.hasOverflowY="data-has-overflow-y",e.overflowXStart="data-overflow-x-start",e.overflowXEnd="data-overflow-x-end",e.overflowYStart="data-overflow-y-start",e.overflowYEnd="data-overflow-y-end",e})({});const be={hasOverflowX:e=>e?{[ce.hasOverflowX]:""}:null,hasOverflowY:e=>e?{[ce.hasOverflowY]:""}:null,overflowXStart:e=>e?{[ce.overflowXStart]:""}:null,overflowXEnd:e=>e?{[ce.overflowXEnd]:""}:null,overflowYStart:e=>e?{[ce.overflowYStart]:""}:null,overflowYEnd:e=>e?{[ce.overflowYEnd]:""}:null,cornerHidden:()=>null},ze={width:0,height:0},Je={xStart:!1,xEnd:!1,yStart:!1,yEnd:!1},wt=t.forwardRef(function(r,h){const{render:L,className:U,overflowEdgeThreshold:n,...s}=r,[Y,b]=t.useState(!1),[W,p]=t.useState(!1),[H,v]=t.useState(!1),[i,X]=t.useState(ze),[g,w]=t.useState(ze),[D,Q]=t.useState(!1),[A,F]=t.useState(Je),k=De(),_=t.useRef(null),m=t.useRef(null),j=t.useRef(null),I=t.useRef(null),y=t.useRef(null),a=t.useRef(null),B=t.useRef(null),c=t.useRef(!1),S=t.useRef(0),O=t.useRef(0),d=t.useRef(0),u=t.useRef(0),f=t.useRef("vertical"),x=pe(),z=pe(),$=t.useRef({x:0,y:0}),[R,E]=t.useState({scrollbarYHidden:!1,scrollbarXHidden:!1,cornerHidden:!1}),K=Qe(n),Z=ue(o=>{const N=o.x-$.current.x,G=o.y-$.current.y;$.current=o,G!==0&&(v(!0),x.start(ve,()=>{v(!1)})),N!==0&&(p(!0),z.start(ve,()=>{p(!1)}))}),q=ue(o=>{o.button===0&&(c.current=!0,S.current=o.clientY,O.current=o.clientX,f.current=o.currentTarget.getAttribute(Ge.orientation),m.current&&(d.current=m.current.scrollTop,u.current=m.current.scrollLeft),y.current&&f.current==="vertical"&&y.current.setPointerCapture(o.pointerId),a.current&&f.current==="horizontal"&&a.current.setPointerCapture(o.pointerId))}),ae=ue(o=>{if(!c.current)return;const N=o.clientY-S.current,G=o.clientX-O.current;if(m.current){const he=m.current.scrollHeight,Ye=m.current.clientHeight,Xe=m.current.scrollWidth,Re=m.current.clientWidth;if(y.current&&j.current&&f.current==="vertical"){const re=P(j.current,"padding","y"),oe=P(y.current,"margin","y"),ne=y.current.offsetHeight,le=j.current.offsetHeight-ne-re-oe,se=N/le;m.current.scrollTop=d.current+se*(he-Ye),o.preventDefault(),v(!0),x.start(ve,()=>{v(!1)})}if(a.current&&I.current&&f.current==="horizontal"){const re=P(I.current,"padding","x"),oe=P(a.current,"margin","x"),ne=a.current.offsetWidth,le=I.current.offsetWidth-ne-re-oe,se=G/le;m.current.scrollLeft=u.current+se*(Xe-Re),o.preventDefault(),p(!0),z.start(ve,()=>{p(!1)})}}}),te=ue(o=>{c.current=!1,y.current&&f.current==="vertical"&&y.current.releasePointerCapture(o.pointerId),a.current&&f.current==="horizontal"&&a.current.releasePointerCapture(o.pointerId)});function T(o){const N=o.pointerType==="touch";if(Q(N),!N){const G=Ke(_.current,o.target);b(G)}}const M=t.useMemo(()=>({hasOverflowX:!R.scrollbarXHidden,hasOverflowY:!R.scrollbarYHidden,overflowXStart:A.xStart,overflowXEnd:A.xEnd,overflowYStart:A.yStart,overflowYEnd:A.yEnd,cornerHidden:R.cornerHidden}),[R.scrollbarXHidden,R.scrollbarYHidden,R.cornerHidden,A]),Se={role:"presentation",onPointerEnter:T,onPointerMove:T,onPointerDown({pointerType:o}){Q(o==="touch")},onPointerLeave(){b(!1)},style:{position:"relative",[ge.scrollAreaCornerHeight]:`${i.height}px`,[ge.scrollAreaCornerWidth]:`${i.width}px`}},Ee=ie("div",r,{state:M,ref:[h,_],props:[Se,s],stateAttributesMapping:be}),ee=t.useMemo(()=>({handlePointerDown:q,handlePointerMove:ae,handlePointerUp:te,handleScroll:Z,cornerSize:i,setCornerSize:X,thumbSize:g,setThumbSize:w,touchModality:D,cornerRef:B,scrollingX:W,setScrollingX:p,scrollingY:H,setScrollingY:v,hovering:Y,setHovering:b,viewportRef:m,rootRef:_,scrollbarYRef:j,scrollbarXRef:I,thumbYRef:y,thumbXRef:a,rootId:k,hiddenState:R,setHiddenState:E,overflowEdges:A,setOverflowEdges:F,viewportState:M,overflowEdgeThreshold:K}),[q,ae,te,Z,i,g,D,B,W,p,H,v,Y,b,m,_,j,I,y,a,k,R,A,M,K]);return Me.jsxs(Fe.Provider,{value:ee,children:[Ne.element,Ee]})});function Qe(e){if(typeof e=="number"){const r=Math.max(0,e);return{xStart:r,xEnd:r,yStart:r,yEnd:r}}return{xStart:Math.max(0,e?.xStart||0),xEnd:Math.max(0,e?.xEnd||0),yStart:Math.max(0,e?.yStart||0),yEnd:Math.max(0,e?.yEnd||0)}}const ke=t.createContext(void 0);function et(){const e=t.useContext(ke);if(e===void 0)throw new Error(Te(55));return e}function tt(e,r){if(typeof IntersectionObserver>"u")return()=>{};const h=new IntersectionObserver(L=>{L.forEach(U=>{U.intersectionRatio>0&&(r(),h.disconnect())})});return h.observe(e),()=>{h.disconnect()}}let J=(function(e){return e.scrollAreaOverflowXStart="--scroll-area-overflow-x-start",e.scrollAreaOverflowXEnd="--scroll-area-overflow-x-end",e.scrollAreaOverflowYStart="--scroll-area-overflow-y-start",e.scrollAreaOverflowYEnd="--scroll-area-overflow-y-end",e})({}),$e=!1;function rt(){$e||qe||(typeof CSS<"u"&&"registerProperty"in CSS&&[J.scrollAreaOverflowXStart,J.scrollAreaOverflowXEnd,J.scrollAreaOverflowYStart,J.scrollAreaOverflowYEnd].forEach(e=>{try{CSS.registerProperty({name:e,syntax:"<length>",inherits:!1,initialValue:"0px"})}catch{}}),$e=!0)}const pt=t.forwardRef(function(r,h){const{render:L,className:U,...n}=r,{viewportRef:s,scrollbarYRef:Y,scrollbarXRef:b,thumbYRef:W,thumbXRef:p,cornerRef:H,setCornerSize:v,setThumbSize:i,rootId:X,setHiddenState:g,hiddenState:w,handleScroll:D,setHovering:Q,setOverflowEdges:A,overflowEdges:F,overflowEdgeThreshold:k}=de(),_=Ue(),m=t.useRef(!0),j=pe(),I=pe();function y(){const u=s.current,f=Y.current,x=b.current,z=W.current,$=p.current,R=H.current;if(!u)return;const E=u.scrollHeight,K=u.scrollWidth,Z=u.clientHeight,q=u.clientWidth,ae=u.scrollTop,te=u.scrollLeft;if(E===0||K===0)return;const T=Z>=E,M=q>=K,Se=q/K,Ee=Z/E,ee=Math.max(0,K-q),o=Math.max(0,E-Z);let N=0,G=0;M||(_==="rtl"?N=V(-te,0,ee):N=V(te,0,ee),G=ee-N);const he=T?0:V(ae,0,o),Ye=T?0:o-he,Xe=M?0:q,Re=T?0:Z,re=P(x,"padding","x"),oe=P(f,"padding","y"),ne=P($,"margin","x"),le=P(z,"margin","y"),se=Xe-re-ne,We=Re-oe-le,je=x?Math.min(x.offsetWidth,se):se,Be=f?Math.min(f.offsetHeight,We):We,He=Math.max(Ie,je*Se),ye=Math.max(Ie,Be*Ee);if(i(l=>l.height===ye&&l.width===He?l:{width:He,height:ye}),f&&z){const l=f.offsetHeight-ye-oe-le,C=E-Z,me=C===0?0:ae/C,Oe=Math.min(l,Math.max(0,me*l));z.style.transform=`translate3d(0,${Oe}px,0)`}if(x&&$){const l=x.offsetWidth-He-re-ne,C=K-q,me=C===0?0:te/C,Oe=_==="rtl"?V(me*l,-l,0):V(me*l,0,l);$.style.transform=`translate3d(${Oe}px,0,0)`}const Ce=V(N,0,ee),Pe=V(G,0,ee),Le=V(he,0,o),Ae=V(Ye,0,o),Ve=[[J.scrollAreaOverflowXStart,Ce],[J.scrollAreaOverflowXEnd,Pe],[J.scrollAreaOverflowYStart,Le],[J.scrollAreaOverflowYEnd,Ae]];for(const[l,C]of Ve)u.style.setProperty(l,`${C}px`);if(R){if(M||T)v({width:0,height:0});else if(!M&&!T){const l=f?.offsetWidth||0,C=x?.offsetHeight||0;v({width:l,height:C})}}g(l=>{const C=T||M;return l.scrollbarYHidden===T&&l.scrollbarXHidden===M&&l.cornerHidden===C?l:{scrollbarYHidden:T,scrollbarXHidden:M,cornerHidden:C}});const fe={xStart:!M&&Ce>k.xStart,xEnd:!M&&Pe>k.xEnd,yStart:!T&&Le>k.yStart,yEnd:!T&&Ae>k.yEnd};A(l=>l.xStart===fe.xStart&&l.xEnd===fe.xEnd&&l.yStart===fe.yStart&&l.yEnd===fe.yEnd?l:fe)}const a=ue(()=>{Ze.flushSync(y)});we(()=>s.current?(rt(),tt(s.current,a)):void 0,[a,s]),we(()=>{queueMicrotask(a)},[a,w,_]),we(()=>{s.current?.matches(":hover")&&Q(!0)},[s,Q]),t.useEffect(()=>{const u=s.current;if(typeof ResizeObserver>"u"||!u)return;const f=new ResizeObserver(a);return f.observe(u),I.start(0,()=>{Promise.all(u.getAnimations({subtree:!0}).map(x=>x.finished)).then(a).catch(()=>{})}),()=>{f.disconnect(),I.clear()}},[a,s,I]);function B(){m.current=!1}const c={role:"presentation",...X&&{"data-id":`${X}-viewport`},...(!w.scrollbarXHidden||!w.scrollbarYHidden)&&{tabIndex:0},className:Ne.className,style:{overflow:"scroll"},onScroll(){s.current&&(a(),m.current||D({x:s.current.scrollLeft,y:s.current.scrollTop}),j.start(100,()=>{m.current=!0}))},onWheel:B,onTouchMove:B,onPointerMove:B,onPointerEnter:B,onKeyDown:B},S=t.useMemo(()=>({hasOverflowX:!w.scrollbarXHidden,hasOverflowY:!w.scrollbarYHidden,overflowXStart:F.xStart,overflowXEnd:F.xEnd,overflowYStart:F.yStart,overflowYEnd:F.yEnd,cornerHidden:w.cornerHidden}),[w.scrollbarXHidden,w.scrollbarYHidden,w.cornerHidden,F]),O=ie("div",r,{ref:[h,s],state:S,props:[c,n],stateAttributesMapping:be}),d=t.useMemo(()=>({computeThumbPosition:a}),[a]);return Me.jsx(ke.Provider,{value:d,children:O})}),_e=t.createContext(void 0);function ot(){const e=t.useContext(_e);if(e===void 0)throw new Error(Te(54));return e}let xe=(function(e){return e.scrollAreaThumbHeight="--scroll-area-thumb-height",e.scrollAreaThumbWidth="--scroll-area-thumb-width",e})({});const gt=t.forwardRef(function(r,h){const{render:L,className:U,orientation:n="vertical",keepMounted:s=!1,...Y}=r,{hovering:b,scrollingX:W,scrollingY:p,hiddenState:H,overflowEdges:v,scrollbarYRef:i,scrollbarXRef:X,viewportRef:g,thumbYRef:w,thumbXRef:D,handlePointerDown:Q,handlePointerUp:A,rootId:F,thumbSize:k}=de(),_=t.useMemo(()=>({hovering:b,scrolling:{horizontal:W,vertical:p}[n],orientation:n,hasOverflowX:!H.scrollbarXHidden,hasOverflowY:!H.scrollbarYHidden,overflowXStart:v.xStart,overflowXEnd:v.xEnd,overflowYStart:v.yStart,overflowYEnd:v.yEnd,cornerHidden:H.cornerHidden}),[b,W,p,n,H,v]),m=Ue();t.useEffect(()=>{const c=g.current,S=n==="vertical"?i.current:X.current;if(!S)return;function O(d){if(!(!c||!S||d.ctrlKey)){if(d.preventDefault(),n==="vertical"){if(c.scrollTop===0&&d.deltaY<0)return}else if(c.scrollLeft===0&&d.deltaX<0)return;if(n==="vertical"){if(c.scrollTop===c.scrollHeight-c.clientHeight&&d.deltaY>0)return}else if(c.scrollLeft===c.scrollWidth-c.clientWidth&&d.deltaX>0)return;n==="vertical"?c.scrollTop+=d.deltaY:c.scrollLeft+=d.deltaX}}return S.addEventListener("wheel",O,{passive:!1}),()=>{S.removeEventListener("wheel",O)}},[n,X,i,g]);const j={...F&&{"data-id":`${F}-scrollbar`},onPointerDown(c){if(c.button===0&&c.currentTarget===c.target&&g.current){if(w.current&&i.current&&n==="vertical"){const S=P(w.current,"margin","y"),O=P(i.current,"padding","y"),d=w.current.offsetHeight,u=i.current.getBoundingClientRect(),f=c.clientY-u.top-d/2-O+S/2,x=g.current.scrollHeight,z=g.current.clientHeight,$=i.current.offsetHeight-d-O-S,E=f/$*(x-z);g.current.scrollTop=E}if(D.current&&X.current&&n==="horizontal"){const S=P(D.current,"margin","x"),O=P(X.current,"padding","x"),d=D.current.offsetWidth,u=X.current.getBoundingClientRect(),f=c.clientX-u.left-d/2-O+S/2,x=g.current.scrollWidth,z=g.current.clientWidth,$=X.current.offsetWidth-d-O-S,R=f/$;let E;m==="rtl"?(E=(1-R)*(x-z),g.current.scrollLeft<=0&&(E=-E)):E=R*(x-z),g.current.scrollLeft=E}Q(c)}},onPointerUp:A,style:{position:"absolute",touchAction:"none",WebkitUserSelect:"none",userSelect:"none",...n==="vertical"&&{top:0,bottom:`var(${ge.scrollAreaCornerHeight})`,insetInlineEnd:0,[xe.scrollAreaThumbHeight]:`${k.height}px`},...n==="horizontal"&&{insetInlineStart:0,insetInlineEnd:`var(${ge.scrollAreaCornerWidth})`,bottom:0,[xe.scrollAreaThumbWidth]:`${k.width}px`}}},I=ie("div",r,{ref:[h,n==="vertical"?i:X],state:_,props:[j,Y],stateAttributesMapping:be}),y=t.useMemo(()=>({orientation:n}),[n]),a=n==="vertical"?H.scrollbarYHidden:H.scrollbarXHidden;return s||!a?Me.jsx(_e.Provider,{value:y,children:I}):null}),xt=t.forwardRef(function(r,h){const{render:L,className:U,...n}=r,s=t.useRef(null),{computeThumbPosition:Y}=et(),{viewportState:b}=de();return we(()=>{if(typeof ResizeObserver>"u")return;const p=new ResizeObserver(Y);return s.current&&p.observe(s.current),()=>{p.disconnect()}},[Y]),ie("div",r,{ref:[h,s],state:b,stateAttributesMapping:be,props:[{role:"presentation",style:{minWidth:"fit-content"}},n]})}),bt=t.forwardRef(function(r,h){const{render:L,className:U,...n}=r,{thumbYRef:s,thumbXRef:Y,handlePointerDown:b,handlePointerMove:W,handlePointerUp:p,setScrollingX:H,setScrollingY:v}=de(),{orientation:i}=ot(),X=t.useMemo(()=>({orientation:i}),[i]);return ie("div",r,{ref:[h,i==="vertical"?s:Y],state:X,props:[{onPointerDown:b,onPointerMove:W,onPointerUp(w){i==="vertical"&&v(!1),i==="horizontal"&&H(!1),p(w)},style:{...i==="vertical"&&{height:`var(${xe.scrollAreaThumbHeight})`},...i==="horizontal"&&{width:`var(${xe.scrollAreaThumbWidth})`}}},n]})}),St=t.forwardRef(function(r,h){const{render:L,className:U,...n}=r,{cornerRef:s,cornerSize:Y,hiddenState:b}=de(),W=ie("div",r,{ref:[h,s],props:[{style:{position:"absolute",bottom:0,insetInlineEnd:0,width:Y.width,height:Y.height}},n]});return b.cornerHidden?null:W});export{wt as S,pt as a,xt as b,gt as c,bt as d,St as e};
